# O que é o SOLID?

A sistemática dos princípios **SOLID** tornam o software mais robusto, escalável e flexível, deixando-o tolerante a mudanças, facilitando a implementação de novos requisitos para a evolução e manutenção do sistema.

# Princípios

* S — Single Responsiblity Principle (Princípio da responsabilidade única)
* O — Open-Closed Principle (Princípio Aberto-Fechado)
* L — Liskov Substitution Principle (Princípio da substituição de Liskov)
* I — Interface Segregation Principle (Princípio da Segregação da Interface)
* D — Dependency Inversion Principle (Princípio da inversão da dependência)


# Benefícios

* Fácil de manter, adaptar e ajustar às alterações de escopo
* Testável
* Fácil entendimento
* Ser expansível
* Fornecer o máximo de reaproveitamento
* Permanecer o máximo de tempo possível em utilização


# Consequências de não utilizar o SOLID

* Falta de coesão. Uma classe pode assumir responsabilidades e processos que não são pertinentes a ela.
* Alto acoplamento. Com mais responsabilidades geram dependências, deixando o sistema engessado e frágil para alterações
* Dificuldades na implementação de testes automatizados
* Dificuldades para reaproveitar o código


# Exemplos

* [S — Single Responsiblity Principle (Princípio da responsabilidade única)](./01-single-responsibility.md)
* [O — Open-Closed Principle (Princípio Aberto-Fechado)](./02-open-closed.md)
* [L — Liskov Substitution Principle (Princípio da substituição de Liskov)](./03-liskov-substitution.md)
* [I — Interface Segregation Principle (Princípio da Segregação da Interface)](./04-interface-segregation.md)
* [D — Dependency Inversion Principle (Princípio da inversão da dependência)](./05-dependency-inversion.md)